# Item 14: Consider Implementing `Comparable`

## Main Takeaway

> Whenever you implement a value class that has a sensible ordering, you should have the class implement the `Comparable` interface so that its instances can be easily sorted, searched, and used in comparison-based collections. When comparing field values in the implementations of teh `compareTo` methods, avoid the use of the `<` and `>` operators. Instead, use the static `compare` methods in teh boxed primitive classes or teh comparator construction methods in the `Comparator` interface.

By implementing `Comparable` you allow your class to interoperate with all of the many generic algorithms and collection implementations that depend on this interface. You gain tremendous amount of power fo a small amount of effort. Virtually all of the value classes in the Java platform libraries, as well as teh enum types (Item 34) implement `Comparable`. If you are writing a value class with an obvious natural ordering, such as alphabetical order, numerical order, or chronological order, you should implement the `Comparable interface:

```java
public interface Comparable<T>{
    int compareTo(T t);
}
```

## `Comparable` - Contract Definition

>Compare this object with the specified object for order. Returns a negative integer, zero, or a positive integer as this object is less than, equal to, or greater than the specified object. Throws `ClassCastException` if the specified object's type prevents it from being compared to this object.
>
>In the following description, the notation `sgn(expression)` designates the mathematical `signum` function, which is defined to return -1, 0, or 1, according to whether the values of teh `expression` is negative, zero, or positive.
>
> - The implementer must ensure that `sgn(x.compareTo(y)) == -sgn(y.compareTo(x))` for all `x` and `y`. (This implies that `x.compareTo(y)` must throw an exception if and off iff `y.compareTo(x))` throws and exception.
> The implementor must also ensure that the relation is transitive: `(x.compareTo(y) > 0 && y.compareTo(z)>0)` implies `x.compareTo(z)>0`.
> Finally, the implementer must ensure that `x.compareTo(y)==0` implies that `sgn(x.compareTo(z))==sgn(y.compareTo(z))`, for all `z`.
> It is strongly recommended, but not required that `(x.compareTo(y)==0)==(x.equals(y))`. Generally speaking, any class that implements the `Comparable` interface and violates this condition should clearly indicate this fact. The recommended language is: "Note: This class has a natural ordering that is inconsistent with `equals`."

Unlike the `equals` method, which imposes a global equivalence relation on all objects, `compareTo` doesn't have to work across objects of different types: when confronted with objects of different types, `compareTo` is permitted to throw `ClassCastException`. Usually, that's exactly what it does.

Classes that depend on comparison include the sorted collections `TreeSet` and `TreeMap` and the utility classes `Collections` and `Arrays` which contain searching and sorting algorithms.

## Navigation

- [All Items](../README.md#items)
- [Previous](./item-13-override-clone-judiciously.md)
- [Next](./item-14-consider-implementing-comparable.md)
